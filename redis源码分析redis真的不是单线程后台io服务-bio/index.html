<!doctype html><html lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>【Redis源码分析】Redis真的不是单线程，后台IO服务 BIO - 维修区刷紫</title>
<meta property="og:title" content="【Redis源码分析】Redis真的不是单线程，后台IO服务 BIO - 维修区刷紫"><meta name=twitter:title content="【Redis源码分析】Redis真的不是单线程，后台IO服务 BIO - 维修区刷紫"><meta name=description content="面试总喜欢被问Redis是单线程还是多线程，千篇一律的回答单线程却不知所以然，严格来说Redis是多线程多进程、单线程处理请求，本文说的就是多线程下的BIO(Background I/O service)。"><meta property="og:description" content="面试总喜欢被问Redis是单线程还是多线程，千篇一律的回答单线程却不知所以然，严格来说Redis是多线程多进程、单线程处理请求，本文说的就是多线程下的BIO(Background I/O service)。"><meta name=twitter:description content="面试总喜欢被问Redis是单线程还是多线程，千篇一律的回答单线程却不知所以然，严格来说Redis是多线程多进程、单线程处理请求，本文说的就是多线程下的BIO(Background I/O service)。"><meta name=author content="金汤力"><link rel=icon type=image/x-icon href=/images/favicon.ico><meta property="og:site_name" content="维修区刷紫"><meta property="og:url" content="/redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90redis%E7%9C%9F%E7%9A%84%E4%B8%8D%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%90%8E%E5%8F%B0io%E6%9C%8D%E5%8A%A1-bio/"><meta property="og:type" content="article"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.120.2"><script src=https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/Base64/1.3.0/base64.min.js integrity="sha512-IFxgh3q1bUsg/sL6qotMkJZTOvPyYSS6mRSSIVnJndN5j9vWcQ+oJyHkelIkRAOaKgdU1ibHJOs4HX15sPtZKw==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b5f7da576488071eb46ec9fe633fa64",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=/css/style.css media=all><link rel=stylesheet href=/css/style-dark.css media="all and (prefers-color-scheme: dark)"><link rel=stylesheet href=/css/syntax.css media=all><link rel=stylesheet href=/css/custom.css media=all><script src=/js/script.js></script><script src=/js/custom.js></script><script defer src=/fontawesome/all.min.js></script></head><body><header class=site-header><nav class=site-navi><h1 class=site-title><a href=/>维修区刷紫</a></h1><ul class=site-navi-items><li class=site-navi-item-archives><a href=/archives/ title=所有文章>所有文章</a></li><li class=site-navi-item-categories><a href=/categories/ title=类别>类别</a></li><li class=site-navi-item-about><a href=/about/ title=关于我>关于我</a></li></ul></nav></header><hr class=site-header-bottom><div class=main role=main><article class=article><h1 class=article-title>【Redis源码分析】Redis真的不是单线程，后台IO服务 BIO</h1><hr class=article-title-bottom><ul class=article-meta><li class=article-meta-date><time>2020-07-24</time></li><li class=article-meta-categories><a href=/categories/redis/><i class="fa-solid fa-folder"></i>
redis
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux%E5%86%85%E6%A0%B8/><i class="fa-solid fa-folder"></i>
Linux内核
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/c/c++/><i class="fa-solid fa-folder"></i>
C/C++
</a>&nbsp;</li></ul><aside class=toc><nav id=TableOfContents></nav></aside><p>面试总喜欢被问Redis是单线程还是多线程，千篇一律的回答单线程却不知所以然，严格来说Redis是多线程多进程、单线程处理请求，本文说的就是多线程下的BIO(Background I/O service)。</p><p>由于redis单线程处理请求，所以某些耗时的操作被作为异步任务，有三种任务分别是：关闭文件、AOF同步磁盘、释放空间。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cm>/* Background job opcodes */</span>
</span></span><span class=line><span class=cl><span class=cp>#define BIO_CLOSE_FILE    0 </span><span class=c1>// close()，重写aof，会关闭旧文件fd，具体实现可参考aof.c的backgroundRewriteDoneHandler()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BIO_AOF_FSYNC     1 </span><span class=c1>// fsync()
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BIO_LAZY_FREE     2 </span><span class=c1>// 延迟释放
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#define BIO_NUM_OPS       3
</span></span></span></code></pre></td></tr></table></div></div><p>每种任务类型都有独立的队列、执行线程、互斥锁，每个任务执行完成并不会callback通知调用方。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span><span class=lnt>132
</span><span class=lnt>133
</span><span class=lnt>134
</span><span class=lnt>135
</span><span class=lnt>136
</span><span class=lnt>137
</span><span class=lnt>138
</span><span class=lnt>139
</span><span class=lnt>140
</span><span class=lnt>141
</span><span class=lnt>142
</span><span class=lnt>143
</span><span class=lnt>144
</span><span class=lnt>145
</span><span class=lnt>146
</span><span class=lnt>147
</span><span class=lnt>148
</span><span class=lnt>149
</span><span class=lnt>150
</span><span class=lnt>151
</span><span class=lnt>152
</span><span class=lnt>153
</span><span class=lnt>154
</span><span class=lnt>155
</span><span class=lnt>156
</span><span class=lnt>157
</span><span class=lnt>158
</span><span class=lnt>159
</span><span class=lnt>160
</span><span class=lnt>161
</span><span class=lnt>162
</span><span class=lnt>163
</span><span class=lnt>164
</span><span class=lnt>165
</span><span class=lnt>166
</span><span class=lnt>167
</span><span class=lnt>168
</span><span class=lnt>169
</span><span class=lnt>170
</span><span class=lnt>171
</span><span class=lnt>172
</span><span class=lnt>173
</span><span class=lnt>174
</span><span class=lnt>175
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=n>pthread_t</span> <span class=n>bio_threads</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>pthread_mutex_t</span> <span class=n>bio_mutex</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>pthread_cond_t</span> <span class=n>bio_newjob_cond</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>pthread_cond_t</span> <span class=n>bio_step_cond</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=n>list</span> <span class=o>*</span><span class=n>bio_jobs</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=c1>// 用于记录每个任务类型的任务数，假如主线程有与BIO共享的数据时，在主线程操作前，会等待直到队列不会有新的任务
</span></span></span><span class=line><span class=cl><span class=c1>// 通常在aof同步以及延迟释放会用到
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>bio_pending</span><span class=p>[</span><span class=n>BIO_NUM_OPS</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* This structure represents a background Job. It is only used locally to this
</span></span></span><span class=line><span class=cl><span class=cm> * file as the API does not expose the internals at all. */</span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>bio_job</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>time_t</span> <span class=n>time</span><span class=p>;</span> <span class=cm>/* Time at which the job was created. */</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 多于三个参数可以传递指针or结构体
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>void</span> <span class=o>*</span><span class=n>arg1</span><span class=p>,</span> <span class=o>*</span><span class=n>arg2</span><span class=p>,</span> <span class=o>*</span><span class=n>arg3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=o>*</span><span class=nf>bioProcessBackgroundJobs</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// 下面三个方法实现均在lazyfree.c
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>lazyfreeFreeObjectFromBioThread</span><span class=p>(</span><span class=n>robj</span> <span class=o>*</span><span class=n>o</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>lazyfreeFreeDatabaseFromBioThread</span><span class=p>(</span><span class=n>dict</span> <span class=o>*</span><span class=n>ht1</span><span class=p>,</span> <span class=n>dict</span> <span class=o>*</span><span class=n>ht2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>lazyfreeFreeSlotsMapFromBioThread</span><span class=p>(</span><span class=n>zskiplist</span> <span class=o>*</span><span class=n>sl</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Make sure we have enough stack to perform all the things we do in the
</span></span></span><span class=line><span class=cl><span class=cm> * main thread. */</span>
</span></span><span class=line><span class=cl><span class=cp>#define REDIS_THREAD_STACK_SIZE (1024*1024*4)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=c1>// 在server.c中InitServerLast()调用
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bioInit</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_attr_t</span> <span class=n>attr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_t</span> <span class=kr>thread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>size_t</span> <span class=n>stacksize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Initialization of state vars and objects */</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>BIO_NUM_OPS</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_cond_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_newjob_cond</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_cond_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_step_cond</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>bio_jobs</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=n>listCreate</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>bio_pending</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>pthread_attr_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>attr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_attr_getstacksize</span><span class=p>(</span><span class=o>&amp;</span><span class=n>attr</span><span class=p>,</span><span class=o>&amp;</span><span class=n>stacksize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>stacksize</span><span class=p>)</span> <span class=n>stacksize</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// 不废话，至少4MB
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=n>stacksize</span> <span class=o>&lt;</span> <span class=n>REDIS_THREAD_STACK_SIZE</span><span class=p>)</span> <span class=n>stacksize</span> <span class=o>*=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_attr_setstacksize</span><span class=p>(</span><span class=o>&amp;</span><span class=n>attr</span><span class=p>,</span> <span class=n>stacksize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// just do it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>BIO_NUM_OPS</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>void</span> <span class=o>*</span><span class=n>arg</span> <span class=o>=</span> <span class=p>(</span><span class=kt>void</span><span class=o>*</span><span class=p>)(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=kr>thread</span><span class=p>,</span><span class=o>&amp;</span><span class=n>attr</span><span class=p>,</span><span class=n>bioProcessBackgroundJobs</span><span class=p>,</span><span class=n>arg</span><span class=p>)</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>serverLog</span><span class=p>(</span><span class=n>LL_WARNING</span><span class=p>,</span><span class=s>&#34;Fatal: Can&#39;t initialize Background Jobs.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>bio_threads</span><span class=p>[</span><span class=n>j</span><span class=p>]</span> <span class=o>=</span> <span class=kr>thread</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>bioCreateBackgroundJob</span><span class=p>(</span><span class=kt>int</span> <span class=n>type</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg1</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg2</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>arg3</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>bio_job</span> <span class=o>*</span><span class=n>job</span> <span class=o>=</span> <span class=n>zmalloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=o>*</span><span class=n>job</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 省略
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 任务线程主体
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=o>*</span><span class=nf>bioProcessBackgroundJobs</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>bio_job</span> <span class=o>*</span><span class=n>job</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=n>type</span> <span class=o>=</span> <span class=p>(</span><span class=kt>unsigned</span> <span class=kt>long</span><span class=p>)</span> <span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>sigset_t</span> <span class=n>sigset</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=cm>/* Check that the type is within the right interval. */</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>type</span> <span class=o>&gt;=</span> <span class=n>BIO_NUM_OPS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>serverLog</span><span class=p>(</span><span class=n>LL_WARNING</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;Warning: bio thread started with wrong type %lu&#34;</span><span class=p>,</span><span class=n>type</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 响应bioKillThreads的调用
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>pthread_setcancelstate</span><span class=p>(</span><span class=n>PTHREAD_CANCEL_ENABLE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_setcanceltype</span><span class=p>(</span><span class=n>PTHREAD_CANCEL_ASYNCHRONOUS</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 意味着线程收到终止信号时，会立即取消
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 屏蔽SIGALRM定时器信号
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>sigemptyset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>sigaddset</span><span class=p>(</span><span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=n>SIGALRM</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>pthread_sigmask</span><span class=p>(</span><span class=n>SIG_BLOCK</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>sigset</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=n>serverLog</span><span class=p>(</span><span class=n>LL_WARNING</span><span class=p>,</span>
</span></span><span class=line><span class=cl>            <span class=s>&#34;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&#34;</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>errno</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>while</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>listNode</span> <span class=o>*</span><span class=n>ln</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 队列没有任务会一直hold着
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>listLength</span><span class=p>(</span><span class=n>bio_jobs</span><span class=p>[</span><span class=n>type</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_newjob_cond</span><span class=p>[</span><span class=n>type</span><span class=p>],</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Pop the job from the queue. */</span>
</span></span><span class=line><span class=cl>        <span class=n>ln</span> <span class=o>=</span> <span class=n>listFirst</span><span class=p>(</span><span class=n>bio_jobs</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>job</span> <span class=o>=</span> <span class=n>ln</span><span class=o>-&gt;</span><span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 成功取出任务，则可以释放锁
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Process the job accordingly to its type. */</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>type</span> <span class=o>==</span> <span class=n>BIO_CLOSE_FILE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>close</span><span class=p>((</span><span class=kt>long</span><span class=p>)</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>type</span> <span class=o>==</span> <span class=n>BIO_AOF_FSYNC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>redis_fsync</span><span class=p>((</span><span class=kt>long</span><span class=p>)</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg1</span><span class=p>);</span> <span class=c1>// syscall fsync
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>type</span> <span class=o>==</span> <span class=n>BIO_LAZY_FREE</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// 原注解意思，
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// arg1为要释放的对象指针
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// arg2、arg3为要释放的redis db指针
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// arg3则是个跳表
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>if</span> <span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>lazyfreeFreeObjectFromBioThread</span><span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg1</span><span class=p>);</span> <span class=c1>// 具体参数见：freeObjAsync
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg2</span> <span class=o>&amp;&amp;</span> <span class=n>job</span><span class=o>-&gt;</span><span class=n>arg3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>lazyfreeFreeDatabaseFromBioThread</span><span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg2</span><span class=p>,</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg3</span><span class=p>);</span> <span class=c1>// 具体参数见：emptyDbAsync
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>else</span> <span class=k>if</span> <span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>                <span class=n>lazyfreeFreeSlotsMapFromBioThread</span><span class=p>(</span><span class=n>job</span><span class=o>-&gt;</span><span class=n>arg3</span><span class=p>);</span> <span class=c1>// 具体参数见：slotToKeyFlushAsync
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>serverPanic</span><span class=p>(</span><span class=s>&#34;Wrong job type in bioProcessBackgroundJobs().&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>zfree</span><span class=p>(</span><span class=n>job</span><span class=p>);</span> <span class=c1>//执行完释放任务
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=cm>/* Lock again before reiterating the loop, if there are no longer
</span></span></span><span class=line><span class=cl><span class=cm>         * jobs to process we&#39;ll block again in pthread_cond_wait(). */</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>listDelNode</span><span class=p>(</span><span class=n>bio_jobs</span><span class=p>[</span><span class=n>type</span><span class=p>],</span><span class=n>ln</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>bio_pending</span><span class=p>[</span><span class=n>type</span><span class=p>]</span><span class=o>--</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=cm>/* Unblock threads blocked on bioWaitStepOfType() if any. */</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_cond_broadcast</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_step_cond</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cm>/* Return the number of pending jobs of the specified type. */</span>
</span></span><span class=line><span class=cl><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=nf>bioPendingJobsOfType</span><span class=p>(</span><span class=kt>int</span> <span class=n>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>bio_pending</span><span class=p>[</span><span class=n>type</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 目前看来redis 5.0也没有用到该方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=nf>bioWaitStepOfType</span><span class=p>(</span><span class=kt>int</span> <span class=n>type</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>long</span> <span class=kt>long</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=n>val</span> <span class=o>=</span> <span class=n>bio_pending</span><span class=p>[</span><span class=n>type</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>val</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_step_cond</span><span class=p>[</span><span class=n>type</span><span class=p>],</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>        <span class=n>val</span> <span class=o>=</span> <span class=n>bio_pending</span><span class=p>[</span><span class=n>type</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>bio_mutex</span><span class=p>[</span><span class=n>type</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 只有在进程奔溃收到SIGSEGV信号，才会执行该方法
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>bioKillThreads</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>err</span><span class=p>,</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>BIO_NUM_OPS</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>pthread_cancel</span><span class=p>(</span><span class=n>bio_threads</span><span class=p>[</span><span class=n>j</span><span class=p>])</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>((</span><span class=n>err</span> <span class=o>=</span> <span class=n>pthread_join</span><span class=p>(</span><span class=n>bio_threads</span><span class=p>[</span><span class=n>j</span><span class=p>],</span><span class=nb>NULL</span><span class=p>))</span> <span class=o>!=</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>serverLog</span><span class=p>(</span><span class=n>LL_WARNING</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;Bio thread for job type #%d can be joined: %s&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>j</span><span class=p>,</span> <span class=n>strerror</span><span class=p>(</span><span class=n>err</span><span class=p>));</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>serverLog</span><span class=p>(</span><span class=n>LL_WARNING</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=s>&#34;Bio thread for job type #%d terminated&#34;</span><span class=p>,</span><span class=n>j</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div></article><ul class=article-share><li><a class=resp-sharing-button__link href="https://facebook.com/sharer/sharer.php?u=/redis%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590redis%25E7%259C%259F%25E7%259A%2584%25E4%25B8%258D%25E6%2598%25AF%25E5%258D%2595%25E7%25BA%25BF%25E7%25A8%258B%25E5%2590%258E%25E5%258F%25B0io%25E6%259C%258D%25E5%258A%25A1-bio/" target=_blank rel=noopener aria-label=Facebook><div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--medium"><div aria-hidden=true class="resp-sharing-button__icon resp-sharing-button__icon--solid"><i class="fa-brands fa-facebook-f"></i></div>Facebook</div></a></li><li><a class=resp-sharing-button__link href="https://x.com/intent/tweet/?text=%e3%80%90Redis%e6%ba%90%e7%a0%81%e5%88%86%e6%9e%90%e3%80%91Redis%e7%9c%9f%e7%9a%84%e4%b8%8d%e6%98%af%e5%8d%95%e7%ba%bf%e7%a8%8b%ef%bc%8c%e5%90%8e%e5%8f%b0IO%e6%9c%8d%e5%8a%a1%20BIO%20-%20%e7%bb%b4%e4%bf%ae%e5%8c%ba%e5%88%b7%e7%b4%ab&amp;url=/redis%25E6%25BA%2590%25E7%25A0%2581%25E5%2588%2586%25E6%259E%2590redis%25E7%259C%259F%25E7%259A%2584%25E4%25B8%258D%25E6%2598%25AF%25E5%258D%2595%25E7%25BA%25BF%25E7%25A8%258B%25E5%2590%258E%25E5%258F%25B0io%25E6%259C%258D%25E5%258A%25A1-bio/" target=_blank rel=noopener aria-label=Twitter><div class="resp-sharing-button resp-sharing-button--x resp-sharing-button--medium"><i class="fa-brands fa-x-twitter"></i></div></a></li></ul><ul class="pager article-pager"><li class=pager-newer><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5linux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ data-toggle=tooltip data-placement=top title=【问题小排查】Linux任务计划crontab不执行的问题排查>&lt; Newer</a></li><li class=pager-older><a href=/redis%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90redis%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84/ data-toggle=tooltip data-placement=top title=【Redis源码分析】Redis启动过程是这样的！>Older ></a></li></ul></div><div class=site-footer><div class=copyright>© 2025 黄泽宏 | <a href=https://beian.miit.gov.cn/ target=_blank>粤ICP备2025417888号-1</a></div><ul class=site-footer-items><li class=site-footer-item-about><a href=/about/ title=About>About</a></li></ul><div class=powerdby>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/taikii/whiteplain>Whiteplain</a>
<script>fetch("https://ghtrk-pixel.fly.dev/goodtracker.png?from=hugo-footer-huangzehong_me&ts="+Date.now())</script></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-16F0MHER15"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-16F0MHER15",{anonymize_ip:!1})}</script></body></html>