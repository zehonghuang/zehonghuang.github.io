<!doctype html><html lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>维修区刷紫</title>
<meta property="og:title" content="维修区刷紫"><meta name=twitter:title content="维修区刷紫"><meta name=author content="金汤力"><link rel=icon type=image/x-icon href=/images/favicon.ico><meta property="og:site_name" content="维修区刷紫"><meta property="og:url" content="/"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.120.2"><link href=/index.xml rel=alternate type=application/rss+xml title=维修区刷紫><link href=/index.xml rel=feed type=application/rss+xml title=维修区刷紫><script src=https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/Base64/1.3.0/base64.min.js integrity="sha512-IFxgh3q1bUsg/sL6qotMkJZTOvPyYSS6mRSSIVnJndN5j9vWcQ+oJyHkelIkRAOaKgdU1ibHJOs4HX15sPtZKw==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b5f7da576488071eb46ec9fe633fa64",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=/css/style.css media=all><link rel=stylesheet href=/css/style-dark.css media="all and (prefers-color-scheme: dark)"><link rel=stylesheet href=/css/syntax.css media=all><link rel=stylesheet href=/css/custom.css media=all><script src=/js/script.js></script><script src=/js/custom.js></script><script defer src=/fontawesome/all.min.js></script></head><body><header class=site-header><nav class=site-navi><h1 class=site-title><a href=/>维修区刷紫</a></h1><ul class=site-navi-items><li class=site-navi-item-archives><a href=/archives/ title=所有文章>所有文章</a></li><li class=site-navi-item-categories><a href=/categories/ title=类别>类别</a></li><li class=site-navi-item-about><a href=/about/ title=关于我>关于我</a></li></ul></nav></header><hr class=site-header-bottom><div class=main role=main><section class="list home-list"><article class=article><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/ class=article-titles><h2 class=article-title>【JRaft源码分析03】成员变化</h2></a><ul class=article-meta><li class=article-meta-date><time>2021-03-17</time></li><li class=article-meta-categories><a href=/categories/cap%E7%90%86%E8%AE%BA/><i class="fa-solid fa-folder"></i>
CAP理论
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/raft%E7%AE%97%E6%B3%95/><i class="fa-solid fa-folder"></i>
RAFT算法
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/><i class="fa-solid fa-folder"></i>
分布式一致性
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/java/><i class="fa-solid fa-folder"></i>
java
</a>&nbsp;</li></ul><div class=article-content><p>第三篇说成员变化，有了对选举和日志复制的认识，这个模块就很轻松简单了。</p><p>成员变化就两种情况，增加删除更换节点，和转移领导人。</p><h2 id=1更改一般节点>1、更改一般节点</h2><p><img src=https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/%E4%B8%80%E8%88%AC%E8%8A%82%E7%82%B9%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96.png alt=一般成员节点变化></p></div><div class=article-readmore><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9003%E6%88%90%E5%91%98%E5%8F%98%E5%8C%96/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/ class=article-titles><h2 class=article-title>【JRaft源码分析02】心跳机制以及日志复制</h2></a><ul class=article-meta><li class=article-meta-date><time>2021-03-14</time></li><li class=article-meta-categories><a href=/categories/cap%E7%90%86%E8%AE%BA/><i class="fa-solid fa-folder"></i>
CAP理论
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/raft%E7%AE%97%E6%B3%95/><i class="fa-solid fa-folder"></i>
RAFT算法
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/><i class="fa-solid fa-folder"></i>
分布式一致性
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/java/><i class="fa-solid fa-folder"></i>
java
</a>&nbsp;</li></ul><div class=article-content><p>日志复制是所有分布式共识算法最重要也是最复杂的部分，需要考虑各种各样安全性，比如机器挂了持久化没做、网络分区导致term&amp;logindex不一致、成员变化带来两个任期相同的leader、异步网络出现日志乱序等等。</p><p>很多个细节，我边看源码边照着论文理解，一个异常判断反复推敲它的作用，想象发生的场景。这是源码级熟悉raft的好处，多多少少能身临其境，获取更多的实战校验。</p><p>后面至少还有两篇，成员变化和日志压缩。</p><p>花了点时间做张较为直观的简化流程图，红色箭头是日志复制的过程。还是挺复杂的，包括不限于Node、LogManager、Replicator、BallotBox、StateMachine之间的调用，其实还有快照，以后再讲。</p><p>本文会分为三部分讲，写请求日志落盘、日志复制、commit执行StateMachine。
<img src=https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/jraft%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6%E7%8A%B6%E6%80%81%E6%9C%BA.png alt=日志复制状态机></p></div><div class=article-readmore><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9002%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6%E4%BB%A5%E5%8F%8A%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/ class=article-titles><h2 class=article-title>【JRaft源码分析01】启用以及选举过程</h2></a><ul class=article-meta><li class=article-meta-date><time>2021-03-04</time></li><li class=article-meta-categories><a href=/categories/cap%E7%90%86%E8%AE%BA/><i class="fa-solid fa-folder"></i>
CAP理论
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/raft%E7%AE%97%E6%B3%95/><i class="fa-solid fa-folder"></i>
RAFT算法
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7/><i class="fa-solid fa-folder"></i>
分布式一致性
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/java/><i class="fa-solid fa-folder"></i>
java
</a>&nbsp;</li></ul><div class=article-content><p>最近潜心cap理论和raft算法，选用了蚂蚁金服的sofa-jraft，深入研究具体的实现。该框架参考自百度的BRAFT，可以说是非常优秀的分布式通用框架，很值得学习。</p><p>Raft算法的理论就不再多说了，感性认识的话可以看这个<a href=http://thesecretlivesofdata.com/raft/>动画</a>，非常好懂。</p><h2 id=1启动入口>1、启动入口</h2><p>示例在github的<a href=https://github.com/zehonghuang/sofa-jraft/tree/master/jraft-example>jraft-example</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>RaftGroupService</span><span class=w> </span><span class=n>raftGroupService</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>new</span><span class=w> </span><span class=n>RaftGroupService</span><span class=p>(</span><span class=n>groupId</span><span class=p>,</span><span class=w> </span><span class=n>serverId</span><span class=p>,</span><span class=w> </span><span class=n>nodeOptions</span><span class=p>,</span><span class=w> </span><span class=n>rpcServer</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>//依次实例化NodeManager、NodeImpl、RpcServer</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Node</span><span class=w> </span><span class=n>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>raftGroupService</span><span class=p>.</span><span class=na>start</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>public</span><span class=w> </span><span class=kd>synchronized</span><span class=w> </span><span class=n>Node</span><span class=w> </span><span class=nf>start</span><span class=p>(</span><span class=kd>final</span><span class=w> </span><span class=kt>boolean</span><span class=w> </span><span class=n>startRpcServer</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>NodeManager</span><span class=p>.</span><span class=na>getInstance</span><span class=p>().</span><span class=na>addAddress</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>serverId</span><span class=p>.</span><span class=na>getEndpoint</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>this</span><span class=p>.</span><span class=na>node</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>RaftServiceFactory</span><span class=p>.</span><span class=na>createAndInitRaftNode</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=na>groupId</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>serverId</span><span class=p>,</span><span class=w> </span><span class=k>this</span><span class=p>.</span><span class=na>nodeOptions</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=p>(</span><span class=n>startRpcServer</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>this</span><span class=p>.</span><span class=na>rpcServer</span><span class=p>.</span><span class=na>startup</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h2 id=2包罗万象的node>2、包罗万象的Node</h2><p>分布式系统关键单体就是节点Node，它包括raft分布式算法中需要的所有行为，不限于选举、投票、日志、复制、接收rpc请求等，梦开始的地方。</p><p><img src=https://raw.githubusercontent.com/zehonghuang/github_blog_bak/master/source/image/Node%E7%BB%93%E6%9E%84%E5%9B%BE.png alt=Node结构图></p></div><div class=article-readmore><a href=/jraft%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%9001%E5%90%AF%E7%94%A8%E4%BB%A5%E5%8F%8A%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5pod%E7%8A%B6%E6%80%81%E4%B8%80%E7%9B%B4terminating/ class=article-titles><h2 class=article-title>【问题小排查】Pod状态一直Terminating</h2></a><ul class=article-meta><li class=article-meta-date><time>2021-02-11</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5/><i class="fa-solid fa-folder"></i>
问题小排查
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/kubernetes/><i class="fa-solid fa-folder"></i>
Kubernetes
</a>&nbsp;</li></ul><div class=article-content><h2 id=need-to-kill-pod>Need to kill Pod</h2><blockquote><p>$ kubectl describe pod/apigateway-6dc48bf8b6-clcwk -n cn-staging</p><p>Normal Killing 39s (x735 over 15h) kubelet, 10.179.80.31 Killing container with id docker://apigateway:Need to kill Pod</p></blockquote><p>可能是磁盘满了，无法创建和删除 pod</p><p>处理建议是参考Kubernetes 最佳实践：<a href=https://tencentcloudcontainerteam.github.io/tke-handbook/best-practice/kubernetes-best-practice-handle-disk-full.html>处理容器数据磁盘被写满</a></p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5pod%E7%8A%B6%E6%80%81%E4%B8%80%E7%9B%B4terminating/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%97%B6%E9%9A%94%E5%A4%A7%E5%8D%8A%E5%B9%B4%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%A1nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82/ class=article-titles><h2 class=article-title>【生产问题】时隔大半年，分享一次Nginx反向代理的需求</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-11-13</time></li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/nginx/><i class="fa-solid fa-folder"></i>
Nginx
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98/><i class="fa-solid fa-folder"></i>
生产问题
</a>&nbsp;</li></ul><div class=article-content><blockquote><p>博客前面分享了一篇<a href=https://huangzehong.me/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%A1nginx%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82/>《分享一个 Nginx 正向代理的另类应用案例》</a>，时隔不久，身为救火队员、万金油的博主又再一次接到了一个奇葩需求：</p></blockquote><blockquote><p>场景和上次有些类似，也是部门引进的第三方应用，部署在各个网络区域，从 OA 办公区域无法直接访问。目前，运营人员都需要登陆 Windows 跳板机，才能打开这些应用的 WEB 控制台。既不方便，而且还有一定 Windows 服务器的维护工作量，于是找到我们团队，希望通过运维手段来解决。</p></blockquote><p>拿到这个需求后，我先问了下各个应用的基本情况，得知每个应用的框架基本是一样的，都是通过 IP+端口直接访问，页面 path 也基本一样，没有唯一性。然后拿到了一个应用 WEB 控制台地址看了下，发现 html 引用的地址都是相对路径。</p><p>乍一想，这用 Nginx 代理不好弄吧？页面 path 一样，没法根据 location 来反代到不同的后端，只能通过不同 Nginx 端口来区分，那就太麻烦了！每次他们新上一个应用，我们就得多加一个新端口来映射，这种的尾大不掉、绵绵不绝事情坚决不干，Say pass。</p><p>再一想，我就想到了上次那个正向代理另类应用方案，感觉可以拿过来改改做动态代理。原理也简单：先和用户约定一个访问形式，比如:</p><blockquote><p>Nginx 代理地址为 myproxy.oa.com，需要代理到 IP 为 192.168.2.100:8080 的控制器，用户需要访问 <a href=http://myproxy.oa.com/192.168.2.100:8080/path>http://myproxy.oa.com/192.168.2.100:8080/path</a>。</p></blockquote></div><div class=article-readmore><a href=/%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%97%B6%E9%9A%94%E5%A4%A7%E5%8D%8A%E5%B9%B4%E5%88%86%E4%BA%AB%E4%B8%80%E6%AC%A1nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%9A%84%E9%9C%80%E6%B1%82/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E6%8E%92%E6%9F%A5-close_wait-%E5%A0%86%E7%A7%AF/ class=article-titles><h2 class=article-title>【问题小排查】排查 CLOSE_WAIT 堆积</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-10-21</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5/><i class="fa-solid fa-folder"></i>
问题小排查
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/><i class="fa-solid fa-folder"></i>
计算机网络
</a>&nbsp;</li></ul><div class=article-content><blockquote><p>TCP 连接的 CLOSE_WAIT 状态，正常情况下是短暂的，如果出现堆积，一般说明应用有问题。</p></blockquote><h3 id=close_wait-堆积的危害>CLOSE_WAIT 堆积的危害</h3><p>每个<code>CLOSE_WAIT</code>连接会占据一个文件描述，堆积大量的<code>CLOSE_WAIT</code>可能造成文件描述符不够用，导致建连或打开文件失败，报错<code>too many open files</code>:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>dial udp 9.215.0.48:9073: socket: too many open files
</span></span></code></pre></td></tr></table></div></div><h3 id=如何判断>如何判断?</h3><p>检查系统<code>CLOSE_WAIT</code>连接数:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>lsof <span class=p>|</span> grep CLOSE_WAIT <span class=p>|</span> wc -l
</span></span></code></pre></td></tr></table></div></div><p>检查指定进程<code>CLOSE_WAIT</code>连接数:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>lsof -p <span class=nv>$PID</span> <span class=p>|</span> grep CLOSE_WAIT <span class=p>|</span> wc -l
</span></span></code></pre></td></tr></table></div></div><h3 id=为什么会产生大量-close_wait>为什么会产生大量 CLOSE_WAIT?</h3><p>我们看下 TCP 四次挥手过程:</p><p><img src=/images/tcp_established.png alt=tcp_established></p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E6%8E%92%E6%9F%A5-close_wait-%E5%A0%86%E7%A7%AF/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5service%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90/ class=article-titles><h2 class=article-title>【问题小排查】Service无法解析</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-09-29</time></li><li class=article-meta-categories><a href=/categories/kubernetes/><i class="fa-solid fa-folder"></i>
Kubernetes
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5/><i class="fa-solid fa-folder"></i>
问题小排查
</a>&nbsp;</li></ul><div class=article-content><h3 id=检查kube-dns或coredns服务是否正常>检查kube-dns或CoreDNS服务是否正常</h3><ol><li>kubelet 启动参数 &ndash;cluster-dns 可以看到 dns 服务的 cluster ip:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ ps -ef <span class=p>|</span> grep kubelet  
</span></span><span class=line><span class=cl>... /usr/bin/kubelet --cluster-dns<span class=o>=</span>172.16.14.217 ...
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>找到 dns 的 service:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ kubectl get svc -n kube-system <span class=p>|</span> grep 172.16.14.217  
</span></span><span class=line><span class=cl>kube-dns              ClusterIP   172.16.14.217   &lt;none&gt;        53/TCP,53/UDP              47d
</span></span></code></pre></td></tr></table></div></div><ol start=3><li>看是否存在 endpoint:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ kubectl -n kube-system describe svc kube-dns <span class=p>|</span> grep -i endpoints  
</span></span><span class=line><span class=cl>Endpoints:         172.16.0.156:53,172.16.0.167:53  
</span></span><span class=line><span class=cl>Endpoints:         172.16.0.156:53,172.16.0.167:53
</span></span></code></pre></td></tr></table></div></div><ol start=4><li>检查 endpoint 的 对应 pod 是否正常:</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>$ kubectl -n kube-system get pod -o wide <span class=p>|</span> grep 172.16.0.156  
</span></span><span class=line><span class=cl>kube-dns-898dbbfc6-hvwlr            3/3       Running   <span class=m>0</span>          8d        172.16.0.156   10.0.0.3
</span></span></code></pre></td></tr></table></div></div></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5service%E6%97%A0%E6%B3%95%E8%A7%A3%E6%9E%90/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E5%85%B3%E4%BA%8E%E6%80%8E%E4%B9%88%E6%9F%A5io%E9%AB%98%E8%B4%9F%E8%BD%BD/ class=article-titles><h2 class=article-title>【问题小排查】关于怎么查IO高负载</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-09-11</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5/><i class="fa-solid fa-folder"></i>
问题小排查
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li></ul><div class=article-content><blockquote><p>系统如果出现 IO WAIT 高，说明 IO 设备的速度跟不上 CPU 的处理速度，CPU 需要在那里干等，
这里的等待实际也占用了 CPU 时间，导致系统负载升高，可能就会影响业务进程的处理速度，导致业务超时。</p></blockquote><h3 id=如何判断->如何判断 ？</h3><p>使用<code>top</code>命令看下当前负载：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>top - 19:42:06 up 23:59,  <span class=m>2</span> users,  load average: 34.64, 35.80, 35.76
</span></span><span class=line><span class=cl>Tasks: <span class=m>679</span> total,   <span class=m>1</span> running, <span class=m>678</span> sleeping,   <span class=m>0</span> stopped,   <span class=m>0</span> zombie
</span></span><span class=line><span class=cl>Cpu<span class=o>(</span>s<span class=o>)</span>: 15.6%us,  1.7%sy,  0.0%ni, 74.7%id,  7.9%wa,  0.0%hi,  0.1%si,  0.0%st
</span></span><span class=line><span class=cl>Mem:  32865032k total, 30989168k used,  1875864k free,   370748k buffers
</span></span><span class=line><span class=cl>Swap:  8388604k total,     5440k used,  8383164k free,  7982424k cached
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
</span></span><span class=line><span class=cl> <span class=m>9783</span> mysql     <span class=m>20</span>   <span class=m>0</span> 17.3g  16g <span class=m>8104</span> S 186.9 52.3   3752:33 mysqld
</span></span><span class=line><span class=cl> <span class=m>5700</span> nginx     <span class=m>20</span>   <span class=m>0</span> 1330m  66m <span class=m>9496</span> S  8.9  0.2   0:20.82 php-fpm
</span></span><span class=line><span class=cl> <span class=m>6424</span> nginx     <span class=m>20</span>   <span class=m>0</span> 1330m  65m <span class=m>8372</span> S  8.3  0.2   0:04.97 php-fpm
</span></span></code></pre></td></tr></table></div></div><p><code>%wa</code>(wait) 表示 IO WAIT 的 cpu 占用，默认看到的是所有核的平均值，要看每个核的<code>%wa</code>值需要按下 &ldquo;1&rdquo;:</p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E5%85%B3%E4%BA%8E%E6%80%8E%E4%B9%88%E6%9F%A5io%E9%AB%98%E8%B4%9F%E8%BD%BD/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E5%A4%84%E7%90%86%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E8%A2%AB%E5%86%99%E6%BB%A1/ class=article-titles><h2 class=article-title>【问题小排查】处理容器数据磁盘被写满</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-09-03</time></li></ul><div class=article-content></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5%E5%A4%84%E7%90%86%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E7%A3%81%E7%9B%98%E8%A2%AB%E5%86%99%E6%BB%A1/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5linux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/ class=article-titles><h2 class=article-title>【问题小排查】Linux任务计划crontab不执行的问题排查</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-08-03</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5/><i class="fa-solid fa-folder"></i>
问题小排查
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li></ul><div class=article-content><p>朋友弄了一个小项目，要我帮忙做下 Linux 系统运维，上线一段时间后，发现项目偶尔会挂掉导致服务不可用。
开发朋友一时之间也没空去研究项目奔溃的根因，只好由我这个运维先写一个项目进程自拉起脚本，
通过 Linux 任务计划每分钟检查一下进程是否存在来避免项目挂了没人管的情况。</p><p>自拉起脚本很简单，随便写几行就搞定了：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=cp>#!/bin/bash
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=nv>processcount</span><span class=o>=</span><span class=k>$(</span>pgrep my_app<span class=p>|</span>wc -l<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>cd</span> <span class=k>$(</span><span class=nb>cd</span> <span class=k>$(</span>dirname <span class=nv>$0</span><span class=k>)</span> <span class=o>&amp;&amp;</span> <span class=nb>pwd</span><span class=k>)</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=o>[[</span> <span class=m>0</span> -eq <span class=nv>$processcount</span> <span class=o>]]</span>
</span></span><span class=line><span class=cl><span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> <span class=s2>&#34;[ </span><span class=k>$(</span>date<span class=k>)</span><span class=s2> ] : my_app is down, start it!&#34;</span> <span class=p>|</span> tee -ai ./checkprocess.log
</span></span><span class=line><span class=cl>        bash ./start.sh <span class=c1>#这里是项目的重启脚本</span>
</span></span><span class=line><span class=cl><span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=nb>echo</span> my_app is OK!
</span></span><span class=line><span class=cl><span class=k>fi</span>
</span></span></code></pre></td></tr></table></div></div><p>然后丢到 crontab，1 分钟执行一次：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>* * * * * bash /data/app_server/checkprocess.sh &gt;/dev/null 2&gt;<span class=p>&amp;</span><span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>-_-不过进程还是挂了</p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E6%8E%92%E6%9F%A5linux%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92crontab%E4%B8%8D%E6%89%A7%E8%A1%8C%E7%9A%84%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/>Read more...</a></div><div class=article-floatclear></div></article></section><ul class="pagination pagination-default"><li class=page-item><a href=/ aria-label=First class=page-link role=button><span aria-hidden=true>&#171;&#171;</span></a></li><li class=page-item><a href=/page/2/ aria-label=Previous class=page-link role=button><span aria-hidden=true>&#171;</span></a></li><li class=page-item><a href=/ aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class="page-item active"><a aria-current=page aria-label="Page 3" class=page-link role=button>3</a></li><li class=page-item><a href=/page/4/ aria-label="Page 4" class=page-link role=button>4</a></li><li class=page-item><a href=/page/5/ aria-label="Page 5" class=page-link role=button>5</a></li><li class=page-item><a href=/page/4/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/page/5/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></div><div class=site-footer><div class=copyright>© 2025 黄泽宏 | <a href=https://beian.miit.gov.cn/ target=_blank>粤ICP备2025417888号-1</a></div><ul class=site-footer-items><li class=site-footer-item-rsslink><a href=/index.xml type=application/rss+xml target=_blank title=RSS><i class="fa-solid fa-rss"></i></a></li><li class=site-footer-item-about><a href=/about/ title=About>About</a></li></ul><div class=powerdby>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/taikii/whiteplain>Whiteplain</a>
<script>fetch("https://ghtrk-pixel.fly.dev/goodtracker.png?from=hugo-footer-huangzehong_me&ts="+Date.now())</script></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-16F0MHER15"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-16F0MHER15",{anonymize_ip:!1})}</script></body></html>