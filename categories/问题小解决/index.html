<!doctype html><html lang=ja><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1"><title>问题小解决 - 维修区刷紫</title>
<meta property="og:title" content="问题小解决 - 维修区刷紫"><meta name=twitter:title content="问题小解决 - 维修区刷紫"><meta name=author content="金汤力"><link rel=icon type=image/x-icon href=/images/favicon.ico><meta property="og:site_name" content="维修区刷紫"><meta property="og:url" content="/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=generator content="Hugo 0.120.2"><link href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/index.xml rel=alternate type=application/rss+xml title=维修区刷紫><link href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/index.xml rel=feed type=application/rss+xml title=维修区刷紫><script src=https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/Base64/1.3.0/base64.min.js integrity="sha512-IFxgh3q1bUsg/sL6qotMkJZTOvPyYSS6mRSSIVnJndN5j9vWcQ+oJyHkelIkRAOaKgdU1ibHJOs4HX15sPtZKw==" crossorigin=anonymous referrerpolicy=no-referrer></script><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?4b5f7da576488071eb46ec9fe633fa64",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script><link rel=stylesheet href=/css/style.css media=all><link rel=stylesheet href=/css/style-dark.css media="all and (prefers-color-scheme: dark)"><link rel=stylesheet href=/css/syntax.css media=all><link rel=stylesheet href=/css/custom.css media=all><script src=/js/script.js></script><script src=/js/custom.js></script><script defer src=/fontawesome/all.min.js></script></head><body><header class=site-header><nav class=site-navi><h1 class=site-title><a href=/>维修区刷紫</a></h1><ul class=site-navi-items><li class=site-navi-item-archives><a href=/archives/ title=所有文章>所有文章</a></li><li class=site-navi-item-categories><a href=/categories/ title=类别>类别</a></li><li class=site-navi-item-about><a href=/about/ title=关于我>关于我</a></li></ul></nav></header><hr class=site-header-bottom><div class=main role=main><section class="list term-list"><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E6%97%A0%E9%9C%80%E9%87%8D%E5%90%AF%E5%9F%BA%E4%BA%8Eprometheus%E5%AF%B9pod%E8%BF%9B%E8%A1%8C%E5%9E%82%E7%9B%B4%E6%89%A9%E7%BC%A9%E5%AE%B9/ class=article-titles><h2 class=article-title>【问题小解决】无需重启，基于Prometheus对Pod进行垂直扩缩容</h2></a><ul class=article-meta><li class=article-meta-date><time>2024-03-07</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/kubernetes/><i class="fa-solid fa-folder"></i>
Kubernetes
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/prometheus/><i class="fa-solid fa-folder"></i>
Prometheus
</a>&nbsp;</li></ul><div class=article-content><p>通常情况下，要修改 Pod 的资源定义，是需要重启 Pod 的。
在<strong>Kubernetes 1.27</strong>中，有一个 Alpha 状态的<code>InPlacePodVerticalScaling</code>开关，开启这一特性，
就能在不重启 Pod 的情况下，修改 Pod 的资源定义。</p><p>要使用这个功能，需要在<code>kube-apiserver</code>的<code>featureGates</code>中显式地设置启用，启用这一特性之后，就可以进行测试了。</p><h3 id=测试一下>测试一下</h3><p>假设下面的 Pod 定义：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>v1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Pod</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>stress</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>myimages/stress-ng:latest</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resizePolicy</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>resourceName</span><span class=p>:</span><span class=w> </span><span class=l>cpu</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>restartPolicy</span><span class=p>:</span><span class=w> </span><span class=l>NotRequired</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span>- <span class=nt>resourceName</span><span class=p>:</span><span class=w> </span><span class=l>memory</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>restartPolicy</span><span class=p>:</span><span class=w> </span><span class=l>RestartContainer    </span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>command</span><span class=p>:</span><span class=w> </span><span class=p>[</span><span class=s2>&#34;sleep&#34;</span><span class=p>,</span><span class=w> </span><span class=s2>&#34;3600&#34;</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>resources</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>limits</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=l>200m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>200M</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>requests</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>cpu</span><span class=p>:</span><span class=w> </span><span class=l>200m</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>memory</span><span class=p>:</span><span class=w> </span><span class=l>200M</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>可以看到，spec 中加入了<code>resizePolicy</code>字段，用来指定对 CPU 和内存的扩缩容策略。内容很直白：</p><ul><li>CPU 的扩缩容策略是<code>NotRequired</code>，即不重启 Pod；</li><li>内存的扩缩容策略是<code>RestartContainer</code>，即重启 Pod。</li></ul></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E6%97%A0%E9%9C%80%E9%87%8D%E5%90%AF%E5%9F%BA%E4%BA%8Eprometheus%E5%AF%B9pod%E8%BF%9B%E8%A1%8C%E5%9E%82%E7%9B%B4%E6%89%A9%E7%BC%A9%E5%AE%B9/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%B9%E5%99%A8%E4%B8%8B%E4%BF%AE%E6%94%B9hosts%E5%A4%B1%E6%95%88/ class=article-titles><h2 class=article-title>【问题小解决】如何解决多容器下修改hosts失效</h2></a><ul class=article-meta><li class=article-meta-date><time>2023-06-22</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/kubernetes/><i class="fa-solid fa-folder"></i>
Kubernetes
</a>&nbsp;</li></ul><div class=article-content><h3 id=问题现象>问题现象</h3><p>业务容器启动的逻辑中，修改了<code>/etc/hosts</code>文件，当 Pod 只存在这一个业务容器时，文件可以修改成功，
但存在多个时 (比如注入了 istio 的 sidecar)，修改可能会失效。</p><h3 id=分析>分析</h3><ol><li>容器中的<code>/etc/hosts</code>是由 kubelet 生成并挂载到 Pod 中所有容器，
如果 Pod 有多个容器，它们挂载的<code>/etc/hosts</code>文件都对应宿主机上同一个文件，
路径通常为<code>/var/lib/kubelet/pods/&lt;pod-uid>/etc-hosts</code>。</li></ol><blockquote><p>如果是 docker 运行时，可以通过<code>docker inspect &lt;container-id> -f {{.HostsPath}}</code>查看。</p></blockquote><ol start=2><li>kubelet 在启动容器时，都会走如下的调用链<code>（makeMounts->makeHostsMount->ensureHostsFile）</code>来给容器挂载 /etc/hosts，
而在 ensureHostsFile 函数中都会重新创建一个新的 etc-hosts 文件，导致在其他容器中对 /etc/hosts 文件做的任何修改都被还原了。</li></ol><p>所以，当 Pod 中存在多个容器时，容器内修改 /etc/hosts 的操作可能会被覆盖回去。</p><h3 id=解决方案>解决方案</h3><h4 id=使用-hostaliases>使用 HostAliases</h4><p>如果只是某一个 workload 需要 hosts，可以用 HostAliases:</p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%A4%9A%E5%AE%B9%E5%99%A8%E4%B8%8B%E4%BF%AE%E6%94%B9hosts%E5%A4%B1%E6%95%88/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E8%A7%A3%E5%86%B3%E5%AE%B9%E5%99%A8%E5%86%85%E6%97%B6%E5%8C%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/ class=article-titles><h2 class=article-title>【问题小解决】解决容器内时区不一致问题</h2></a><ul class=article-meta><li class=article-meta-date><time>2023-03-17</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/kubernetes/><i class="fa-solid fa-folder"></i>
Kubernetes
</a>&nbsp;</li></ul><div class=article-content><blockquote><p>业务程序在使用时间的时候(比如打印日志)，没有指定时区，使用的系统默认时区，
而基础镜像一般默认使用 UTC 时间，程序输出时间戳的时候，就与国内的时间相差 8 小时。</p><blockquote><p>游戏<strong>全球对战服</strong>场景这个问题更要命，开发需要通过时间计算同步帧的偏移量，如果这个时候还要重新计算时区是非常浪费计算资源的（-_-）</p></blockquote></blockquote><h3 id=方案一指定-tz-环境变量>方案一：指定 TZ 环境变量</h3><p>很多编程语言都支持<code>TZ</code>这个用于设置时区的环境变量，可以在部署工作负载的时候，为容器指定该环境变量，示例：</p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E8%A7%A3%E5%86%B3%E5%AE%B9%E5%99%A8%E5%86%85%E6%97%B6%E5%8C%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5pod%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84shell%E8%84%9A%E6%9C%AC/ class=article-titles><h2 class=article-title>【问题小解决】提供一个直接进入Pod网络命名空间的Shell脚本</h2></a><ul class=article-meta><li class=article-meta-date><time>2022-07-07</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/kuberntees/><i class="fa-solid fa-folder"></i>
Kuberntees
</a>&nbsp;</li></ul><div class=article-content>我们使用 Kubernetes 时难免发生一些网络问题，往往需要进入容器的网络命名空间 (netns) 中，进行一些网络调试来定位问题，这里直接提供一个脚本，申请各种步骤
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/bin/bash # 函数：进入网络命名空间并进行调试 enter_netns() { local pod_name=$1 local namespace=$2 local container_name=$3 # 获取指定 Pod 中指定容器的容器 ID container_id=$(kubectl -n $namespace get pod $pod_name -o jsonpath="{.status.containerStatuses[?(@.name==\"$container_name\")].containerID}" | sed 's|containerd://||') if [ -z "$container_id" ]; then echo "未找到 Pod $pod_name 中容器 $container_name 在命名空间 $namespace 中的容器 ID" exit 1 fi # 获取容器进程的 PID pid=$(crictl inspect $container_id | grep -i '"pid"' | head -n 1 | awk '{print $2}' | sed 's/,//') if [ -z "$pid" ]; then echo "未找到容器 $container_id 的 PID" exit 1 fi # 进入容器的网络命名空间 echo "进入 Pod $pod_name 中容器 $container_name 的网络命名空间，PID 为 $pid" nsenter -n --target $pid } # 检查是否提供了必要的参数 if [ $# -ne 3 ]; then echo "用法: $0 &lt;pod_name> &lt;namespace> &lt;container_name>" exit 1 fi # 调用函数进入网络命名空间 enter_netns $1 $2 $3 调试网络 成功进入容器的 netns，可以使用节点上的网络工具进行调试网络，可以首先使用ip a验证下 ip 地址是否为 pod ip:</div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5pod%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84shell%E8%84%9A%E6%9C%AC/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3pid%E8%80%97%E5%B0%BD%E7%9A%84%E5%8D%B1%E5%AE%B3/ class=article-titles><h2 class=article-title>【问题小解决】PID耗尽的危害</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-05-21</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li></ul><div class=article-content><h3 id=如何判断-pid-耗尽>如何判断 PID 耗尽</h3><p>首先要确认当前的 PID 限制，检查全局 PID 最大限制:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /proc/sys/kernel/pid_max
</span></span></code></pre></td></tr></table></div></div><p>也检查下线程数限制：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>cat /proc/sys/kernel/threads-max
</span></span></code></pre></td></tr></table></div></div><p>再检查下当前用户是否还有<code>ulimit</code>限制最大进程数。</p><p>确认当前实际 PID 数量，检查当前用户的 PID 数量:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>ps -eLf <span class=p>|</span> wc -l
</span></span></code></pre></td></tr></table></div></div><p>如果发现实际 PID 数量接近最大限制说明 PID 就可能会爆满导致经常有进程无法启动，
低版本内核可能报错:<code>Cannot allocate memory</code>，这个报错信息不准确，
在内核 4.1 以后改进了: <a href=https://github.com/torvalds/linux/commit/35f71bc0a09a45924bed268d8ccd0d3407bc476f>https://github.com/torvalds/linux/commit/35f71bc0a09a45924bed268d8ccd0d3407bc476f</a></p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3pid%E8%80%97%E5%B0%BD%E7%9A%84%E5%8D%B1%E5%AE%B3/>Read more...</a></div><div class=article-floatclear></div></article><article class=article><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E4%B9%8B%E5%8F%8C%E4%B8%BB%E5%A4%9A%E4%BB%8E/ class=article-titles><h2 class=article-title>【问题小解决】MySQL高可用集群之双主多从</h2></a><ul class=article-meta><li class=article-meta-date><time>2020-05-14</time></li><li class=article-meta-categories><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/><i class="fa-solid fa-folder"></i>
问题小解决
</a>&nbsp;</li><li class=article-meta-categories><a href=/categories/linux/><i class="fa-solid fa-folder"></i>
Linux
</a>&nbsp;</li></ul><div class=article-content><p>通常MySQL主从复制主要用来解决读写分离，分担服务器压力。MySQL互为主备实现服务的高可用；这里同时基于高可用和负载均衡。</p><p><img src=/images/mysql-ha.png alt=mysql-ha></p><p>环境准备</p><table><thead><tr><th>主机名/角色</th><th>VIP</th><th>IP地址</th><th>操作系统</th><th>MySQL版本</th></tr></thead><tbody><tr><td>Node0/master1</td><td>172.16.10.100</td><td>172.16.10.10</td><td>CentOS8.1.1911</td><td>8.0.17</td></tr><tr><td>Node1/master2</td><td></td><td>172.16.10.11</td><td>CentOS8.1.1911</td><td>8.0.17</td></tr><tr><td>Node2/slave1</td><td></td><td>172.16.10.12</td><td>CentOS8.1.1911</td><td>8.0.17</td></tr></tbody></table><h3 id=安装mysql>安装MySQL</h3><p>在所有节点上执行<code>dnf -y install mysql mysql-server</code>，并在master节点上配置server-id并开启bin-log</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>vi /etc/my.cnf.d/mysql-server.cnf
</span></span><span class=line><span class=cl><span class=o>[</span>mysqld<span class=o>]</span>
</span></span><span class=line><span class=cl><span class=c1># 主数据库端ID号，全局唯一，通常用IP地址最后一位</span>
</span></span><span class=line><span class=cl><span class=nv>server_id</span> <span class=o>=</span> <span class=m>10</span>
</span></span><span class=line><span class=cl><span class=c1># 开启二进制日志</span>
</span></span><span class=line><span class=cl>log-bin <span class=o>=</span> mysql-bin
</span></span><span class=line><span class=cl><span class=c1># 需要复制的数据库名，如果复制多个数据库，重复设置这个选项即可</span>
</span></span><span class=line><span class=cl>binlog-do-db <span class=o>=</span> <span class=nb>test</span>
</span></span><span class=line><span class=cl><span class=c1># 将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中</span>
</span></span><span class=line><span class=cl>log-slave-updates
</span></span><span class=line><span class=cl><span class=c1># 控制binlog的写入频率。每执行多少次事务写入一次(这个参数性能消耗很大，但可减小MySQL崩溃造成的损失)</span>
</span></span><span class=line><span class=cl><span class=nv>sync_binlog</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># 下面这两个参数非常重要</span>
</span></span><span class=line><span class=cl><span class=c1># 这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突，master2上面改为2</span>
</span></span><span class=line><span class=cl><span class=nv>auto_increment_offset</span> <span class=o>=</span> <span class=m>1</span>
</span></span><span class=line><span class=cl><span class=c1># 这个参数一般用在主主同步中，用来错开自增值, 防止键值冲突</span>
</span></span><span class=line><span class=cl><span class=nv>auto_increment_increment</span> <span class=o>=</span> <span class=m>2</span>
</span></span><span class=line><span class=cl><span class=c1># 二进制日志自动删除的天数，默认值为0,表示“没有自动删除”，启动时和二进制日志循环时可能删除</span>
</span></span><span class=line><span class=cl><span class=nv>expire_logs_days</span> <span class=o>=</span> <span class=m>7</span>
</span></span><span class=line><span class=cl><span class=c1># 将函数复制到slave</span>
</span></span><span class=line><span class=cl><span class=nv>log_bin_trust_function_creators</span> <span class=o>=</span> <span class=m>1</span>
</span></span></code></pre></td></tr></table></div></div><p>执行<code>systemctl enable --now mysqld</code>运行Mysql</p></div><div class=article-readmore><a href=/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3mysql%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4%E4%B9%8B%E5%8F%8C%E4%B8%BB%E5%A4%9A%E4%BB%8E/>Read more...</a></div><div class=article-floatclear></div></article></section></div><div class=site-footer><div class=copyright>© 2025 黄泽宏 | <a href=https://beian.miit.gov.cn/ target=_blank>粤ICP备2025417888号-1</a></div><ul class=site-footer-items><li class=site-footer-item-rsslink><a href=/categories/%E9%97%AE%E9%A2%98%E5%B0%8F%E8%A7%A3%E5%86%B3/index.xml type=application/rss+xml target=_blank title=RSS><i class="fa-solid fa-rss"></i></a></li><li class=site-footer-item-about><a href=/about/ title=About>About</a></li></ul><div class=powerdby>Powered by <a href=https://gohugo.io/>Hugo</a> and <a href=https://github.com/taikii/whiteplain>Whiteplain</a>
<script>fetch("https://ghtrk-pixel.fly.dev/goodtracker.png?from=hugo-footer-huangzehong_me&ts="+Date.now())</script></div></div><script async src="https://www.googletagmanager.com/gtag/js?id=G-16F0MHER15"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-16F0MHER15",{anonymize_ip:!1})}</script></body></html>